{
  "manifest": {
    "name": "@hotwired/turbo-rails",
    "version": "8.0.13",
    "description": "The speed of a single-page web application without having to write any JavaScript",
    "module": "app/javascript/turbo/index.js",
    "main": "app/assets/javascripts/turbo.js",
    "files": [
      "app/javascript/turbo"
    ],
    "exports": {
      ".": {
        "import": "./app/javascript/turbo/index.js",
        "require": "./app/assets/javascripts/turbo.js"
      }
    },
    "scripts": {
      "build": "rollup -c",
      "prerelease": "yarn build && git --no-pager diff && echo && npm pack --dry-run && echo && read -n 1 -p \"Look OK? Press any key to publish and commit v$npm_package_version\" && echo",
      "release": "npm publish && git commit -am \"$npm_package_name v$npm_package_version\" && git push"
    },
    "dependencies": {
      "@hotwired/turbo": "^8.0.13",
      "@rails/actioncable": "^7.0"
    },
    "devDependencies": {
      "@rollup/plugin-node-resolve": "^11.0.1",
      "rollup": "^2.35.1",
      "rollup-plugin-terser": "^7.0.2",
      "terser": "^5.22.0"
    },
    "license": "MIT",
    "author": {
      "name": "Basecamp, LLC"
    },
    "contributors": [
      {
        "name": "David Heinemeier Hansson",
        "email": "david@basecamp.com"
      },
      {
        "name": "Javan Makhmali",
        "email": "javan@javan.us"
      },
      {
        "name": "Sam Stephenson",
        "email": "sstephenson@gmail.com"
      }
    ],
    "keywords": [
      "hotwire",
      "turbo",
      "rails"
    ],
    "repository": {
      "type": "git",
      "url": "git+https://github.com/hotwired/turbo-rails.git"
    },
    "bugs": {
      "url": "https://github.com/hotwired/turbo-rails/issues"
    },
    "homepage": "https://github.com/hotwired/turbo-rails",
    "publishConfig": {
      "access": "public"
    },
    "_registry": "npm",
    "_loc": "/home/sofiz/.cache/yarn/v6/npm-@hotwired-turbo-rails-8.0.13-7016651f7144053992ce5096bb95495f8faa5854-integrity/node_modules/@hotwired/turbo-rails/package.json",
    "readmeFilename": "README.md",
    "readme": "# <img src=\"assets/logo.png?sanitize=true\" width=\"24\" height=\"24\" alt=\"Turbo\"> Turbo\n\n[Turbo](https://turbo.hotwired.dev) gives you the speed of a single-page web application without having to write any JavaScript. Turbo accelerates links and form submissions without requiring you to change your server-side generated HTML. It lets you carve up a page into independent frames, which can be lazy-loaded and operate as independent components. And finally, helps you make partial page updates using just HTML and a set of CRUD-like container tags. These three techniques reduce the amount of custom JavaScript that many web applications need to write by an order of magnitude. And for the few dynamic bits that are left, you're invited to finish the job with [Stimulus](https://github.com/hotwired/stimulus).\n\nOn top of accelerating web applications, Turbo was built from the ground-up to form the foundation of hybrid native applications. Write the navigational shell of your [Android](https://github.com/hotwired/turbo-android) or [iOS](https://github.com/hotwired/turbo-ios) app using the standard platform tooling, then seamlessly fill in features from the web, following native navigation patterns. Not every mobile screen needs to be written in Swift or Kotlin to feel native. With Turbo, you spend less time wrangling JSON, waiting on app stores to approve updates, or reimplementing features you've already created in HTML.\n\nTurbo is a language-agnostic framework written in JavaScript, but this gem builds on top of those basics to make the integration with Rails as smooth as possible. You can deliver turbo updates via model callbacks over Action Cable, respond to controller actions with native navigation or standard redirects, and render turbo frames with helpers and layout-free responses.\n\n## Navigate with Turbo Drive\n\nTurbo is a continuation of the ideas from the previous [Turbolinks](https://github.com/turbolinks/turbolinks) framework, and the heart of that past approach lives on as Turbo Drive. When installed, Turbo automatically intercepts all clicks on `<a href>` links to the same domain. When you click an eligible link, Turbo prevents the browser from following it. Instead, Turbo changes the browser’s URL using the History API, requests the new page using `fetch`, and then renders the HTML response.\n\nDuring rendering, Turbo replaces the current `<body>` element outright and merges the contents of the `<head>` element. The JavaScript window and document objects, and the `<html>` element, persist from one rendering to the next.\n\nWhereas Turbolinks previously just dealt with links, Turbo can now also process form submissions and responses. This means the entire flow in the web application is wrapped into Turbo, making all the parts fast. No more need for `data-remote=true`.\n\nTurbo Drive can be disabled on a per-element basis by annotating the element or any of its ancestors with `data-turbo=\"false\"`. If you want Turbo Drive to be disabled by default, then you can adjust your import like this:\n\n```js\nimport \"@hotwired/turbo-rails\"\nTurbo.session.drive = false\n```\n\nThen you can use `data-turbo=\"true\"` to enable Drive on a per-element basis.\n\n[See documentation](https://turbo.hotwired.dev/handbook/drive).\n\n## Decompose with Turbo Frames\n\nTurbo reinvents the old HTML technique of frames without any of the drawbacks that lead to developers abandoning it. With Turbo Frames, **you can treat a subset of the page as its own component**, where links and form submissions **replace only that part**. This removes an entire class of problems around partial interactivity that before would have required custom JavaScript.\n\nIt also makes it dead easy to carve a single page into smaller pieces that can all live on their own cache timeline. While the bulk of the page might easily be cached between users, a small personalized toolbar perhaps cannot. With Turbo::Frames, you can designate the toolbar as a frame, which will be **lazy-loaded automatically** by the publicly-cached root page. This means simpler pages, easier caching schemes with fewer dependent keys, and all without needing to write a lick of custom JavaScript.\n\nThis gem provides a `turbo_frame_tag` helper to create those frames.\n\nFor instance:\n```erb\n<%# app/views/todos/show.html.erb %>\n<%= turbo_frame_tag @todo do %>\n  <p><%= @todo.description %></p>\n\n  <%= link_to 'Edit this todo', edit_todo_path(@todo) %>\n<% end %>\n\n<%# app/views/todos/edit.html.erb %>\n<%= turbo_frame_tag @todo do %>\n  <%= render \"form\" %>\n\n  <%= link_to 'Cancel', todo_path(@todo) %>\n<% end %>\n```\n\nWhen the user clicks on the `Edit this todo` link, as a direct response to this user interaction, the turbo frame will be automatically replaced with the one in the `edit.html.erb` page.\n\n[See documentation](https://turbo.hotwired.dev/handbook/frames).\n\n### A note on custom layouts\n\nIn order to render turbo frame requests without the application layout, Turbo registers a custom [layout method](https://api.rubyonrails.org/classes/ActionView/Layouts/ClassMethods.html#method-i-layout).\nIf your application uses custom layout resolution, you have to make sure to return `\"turbo_rails/frame\"` (or `false` for TurboRails < 1.4.0) for turbo frame requests:\n\n```ruby\nlayout :custom_layout\n\ndef custom_layout\n  return \"turbo_rails/frame\" if turbo_frame_request?\n\n  # ... your custom layout logic\n```\n\nIf you are using a custom, but \"static\" layout,\n\n```ruby\nlayout \"some_static_layout\"\n```\n\nyou **have** to change it to a layout method in order to conditionally return `\"turbo_rails/frame\"` for turbo frame requests:\n\n```ruby\nlayout :custom_layout\n\ndef custom_layout\n  return \"turbo_rails/frame\" if turbo_frame_request?\n\n  \"some_static_layout\"\n```\n\n## Come Alive with Turbo Streams\n\nPartial page updates that are **delivered asynchronously over a web socket connection** is the hallmark of modern, reactive web applications. With Turbo Streams, you can get all of that modern goodness using the existing server-side HTML you're already rendering to deliver the first page load. With a set of simple CRUD container tags, you can send HTML fragments over the web socket (or in response to direct interactions), and see the page change in response to new data. Again, **no need to construct an entirely separate API**, **no need to wrangle JSON**, **no need to reimplement the HTML construction in JavaScript**. Take the HTML you're already making, wrap it in an update tag, and, voila, your page comes alive.\n\nWith this Rails integration, you can create these asynchronous updates directly in response to your model changes. Turbo uses Active Jobs to provide asynchronous partial rendering and Action Cable to deliver those updates to subscribers.\n\nThis gem provides a `turbo_stream_from` helper to create a turbo stream.\n\n```erb\n<%# app/views/todos/show.html.erb %>\n<%= turbo_stream_from dom_id(@todo) %>\n\n<%# Rest of show here %>\n```\n\n### Testing Turbo Stream Broadcasts\n\nReceiving server-generated Turbo Broadcasts requires a connected Web Socket.\nViews that render `<turbo-cable-stream-source>` elements with the\n`#turbo_stream_from` view helper incur a slight delay before they're ready to\nreceive broadcasts. In System Tests, that delay can disrupt Capybara's built-in\nsynchronization mechanisms that wait for or assert on content that's broadcast\nover Web Sockets. For example, consider a test that navigates to a page and then\nimmediately asserts that broadcast content is present:\n\n```ruby\ntest \"renders broadcasted Messages\" do\n  message = Message.new content: \"Hello, from Action Cable\"\n\n  visit \"/\"\n  click_link \"All Messages\"\n  message.save! # execute server-side code to broadcast a Message\n\n  assert_text message.content\nend\n```\n\nIf the call to `Message#save!` executes quickly enough, it might beat-out any\n`<turbo-cable-stream-source>` elements rendered by the call to `click_link \"All\nMessages\"`.\n\nTo wait for any disconnected `<turbo-cable-stream-source>` elements to connect,\ncall [`#connect_turbo_cable_stream_sources`](https://github.com/hotwired/turbo-rails/blob/main/lib/turbo/system_test_helper.rb):\n\n```diff\n test \"renders broadcasted Messages\" do\n   message = Message.new content: \"Hello, from Action Cable\"\n\n   visit \"/\"\n   click_link \"All Messages\"\n+  connect_turbo_cable_stream_sources\n   message.save! # execute server-side code to broadcast a Message\n\n   assert_text message.content\n end\n```\n\nBy default, calls to [`#visit`](https://rubydoc.info/github/teamcapybara/capybara/master/Capybara/Session:visit) will wait for all `<turbo-cable-stream-source>` elements to connect. You can control this by modifying the `config.turbo.test_connect_after_actions`. For example, to wait after calls to [`#click_link`](https://rubydoc.info/github/teamcapybara/capybara/master/Capybara/Node/Actions:click_link), add the following to `config/environments/test.rb`:\n\n```ruby\n# config/environments/test.rb\n\nconfig.turbo.test_connect_after_actions << :click_link\n```\n\nTo disable automatic connecting, set the configuration to `[]`:\n\n```ruby\n# config/environments/test.rb\n\nconfig.turbo.test_connect_after_actions = []\n```\n\n[See documentation](https://turbo.hotwired.dev/handbook/streams).\n\n## Installation\n\nThis gem is automatically configured for applications made with Rails 7+ (unless --skip-hotwire is passed to the generator). But if you're on Rails 6, you can install it manually:\n\n1. Add the `turbo-rails` gem to your Gemfile: `gem 'turbo-rails'`\n2. Run `./bin/bundle install`\n3. Run `./bin/rails turbo:install`\n\nRunning `turbo:install` will install through NPM or Bun if a JavaScript runtime is used in the application. Otherwise the asset pipeline version is used. To use the asset pipeline version, you must have `importmap-rails` installed first and listed higher in the Gemfile.\n\nIf you're using node and need to use the cable consumer, you can import [`cable`](https://github.com/hotwired/turbo-rails/blob/main/app/javascript/turbo/cable.js) (`import { cable } from \"@hotwired/turbo-rails\"`), but ensure that your application actually *uses* the members it `import`s when using this style (see [turbo-rails#48](https://github.com/hotwired/turbo-rails/issues/48)).\n\nThe `Turbo` instance is automatically assigned to `window.Turbo` upon import:\n\n```js\nimport \"@hotwired/turbo-rails\"\n```\n\n## Usage\n\nYou can watch [the video introduction to Hotwire](https://hotwired.dev/#screencast), which focuses extensively on demonstrating Turbo in a Rails demo. Then you should familiarize yourself with [Turbo handbook](https://turbo.hotwired.dev/handbook/introduction) to understand Drive, Frames, and Streams in-depth. Finally, dive into the code documentation by starting with [`Turbo::FramesHelper`](https://github.com/hotwired/turbo-rails/blob/main/app/helpers/turbo/frames_helper.rb), [`Turbo::StreamsHelper`](https://github.com/hotwired/turbo-rails/blob/main/app/helpers/turbo/streams_helper.rb), [`Turbo::Streams::TagBuilder`](https://github.com/hotwired/turbo-rails/blob/main/app/models/turbo/streams/tag_builder.rb), and [`Turbo::Broadcastable`](https://github.com/hotwired/turbo-rails/blob/main/app/models/concerns/turbo/broadcastable.rb).\n\nNote that in development, the default Action Cable adapter is the single-process `async` adapter. This means that turbo updates are only broadcast within that same process. So you can't start `bin/rails console` and trigger Turbo broadcasts and expect them to show up in a browser connected to a server running in a separate `bin/dev` or `bin/rails server` process. Instead, you should use the web-console when needing to manaually trigger Turbo broadcasts inside the same process. Add \"console\" to any action or \"<%= console %>\" in any view to make the web console appear.  \n\n### RubyDoc Documentation\n\nFor the API documentation covering this gem's classes and packages, [visit the RubyDoc page](https://rubydoc.info/github/hotwired/turbo-rails/main).\nNote that this documentation is updated automatically from the main branch, so it may contain features that are not released yet.\n\n- [Turbo Drive Helpers](https://rubydoc.info/github/hotwired/turbo-rails/main/Turbo/DriveHelper)\n- [Turbo Frames Helpers](https://rubydoc.info/github/hotwired/turbo-rails/main/Turbo/FramesHelper)\n- [Turbo Streams View Helpers](https://rubydoc.info/github/hotwired/turbo-rails/main/Turbo/StreamsHelper)\n- [Turbo Streams Broadcast Methods](https://rubydoc.info/github/hotwired/turbo-rails/main/Turbo/Broadcastable)\n- [Turbo Streams Channel](https://rubydoc.info/github/hotwired/turbo-rails/main/Turbo/StreamsChannel)\n- [Turbo Native Navigation](https://rubydoc.info/github/hotwired/turbo-rails/main/Turbo/Native/Navigation)\n- [Turbo Test Assertions](https://rubydoc.info/github/hotwired/turbo-rails/main/Turbo/TestAssertions)\n- [Turbo Integration Test Assertions](https://rubydoc.info/github/hotwired/turbo-rails/main/Turbo/TestAssertions/IntegrationTestAssertions)\n- [Turbo Broadcastable Test Helper](https://rubydoc.info/github/hotwired/turbo-rails/main/Turbo/Broadcastable/TestHelper)\n- [Turbo System Test Helper](https://rubydoc.info/github/hotwired/turbo-rails/main/Turbo/SystemTestHelper)\n\n## Compatibility with Rails UJS\n\nTurbo can coexist with Rails UJS, but you need to take a series of upgrade steps to make it happen. See [the upgrading guide](https://github.com/hotwired/turbo-rails/blob/main/UPGRADING.md).\n\n## Testing\n\nThe [`Turbo::TestAssertions`](./lib/turbo/test_assertions.rb) concern provides Turbo Stream test helpers that assert the presence or absence ofs  s  `<turbo-stream>` elements in a rendered fragment of HTML. `Turbo::TestAssertions` are automatically included in [`ActiveSupport::TestCase`](https://edgeapi.rubyonrails.org/classes/ActiveSupport/TestCase.html) and depend on the presence of [`rails-dom-testing`](https://github.com/rails/rails-dom-testing/) assertions.\n\nThe [`Turbo::TestAssertions::IntegrationTestAssertions`](./lib/turbo/test_assertions/integration_test_assertions.rb) are built on top of `Turbo::TestAssertions`, and add support for passing a `status:` keyword. They are automatically included in [`ActionDispatch::IntegrationTest`](https://edgeguides.rubyonrails.org/testing.html#integration-testing).\n\nThe [`Turbo::Broadcastable::TestHelper`](./lib/turbo/broadcastable/test_helper.rb) concern provides Action Cable-aware test helpers that assert that `<turbo-stream>` elements were or were not broadcast over Action Cable. `Turbo::Broadcastable::TestHelper` is automatically included in [`ActiveSupport::TestCase`](https://edgeapi.rubyonrails.org/classes/ActiveSupport/TestCase.html).\n\n### Rendering Outside of a Request\n\nTurbo utilizes [ActionController::Renderer][] to render templates and partials\noutside the context of the request-response cycle. If you need to render a\nTurbo-aware template, partial, or component, use [ActionController::Renderer][]:\n\n```ruby\nApplicationController.renderer.render template: \"posts/show\", assigns: { post: Post.first } # => \"<html>…\"\nPostsController.renderer.render :show, assigns: { post: Post.first } # => \"<html>…\"\n```\n\nAs a shortcut, you can also call render directly on the controller class itself:\n\n```ruby\nApplicationController.render template: \"posts/show\", assigns: { post: Post.first } # => \"<html>…\"\nPostsController.render :show, assigns: { post: Post.first } # => \"<html>…\"\n```\n\n[ActionController::Renderer]: https://api.rubyonrails.org/classes/ActionController/Renderer.html\n\n## Development\n\nRun the tests with `./bin/test`.\n\n### Using local Turbo version\n\nOften you might want to test changes made locally to [Turbo lib](https://github.com/hotwired/turbo) itself. To package your local development version of Turbo you can use [yarn link](https://classic.yarnpkg.com/lang/en/docs/cli/link/) feature:\n\n```sh\ncd <local-turbo-dir>\nyarn link\n\ncd <local-turbo-rails-dir>\nyarn link @hotwired/turbo\n\n# Build the JS distribution files...\nyarn build\n# ...and commit the changes\n```\n\nNow you can reference your version of turbo-rails in your Rails projects packaged with your local version of Turbo.\n\n## Contributing\n\nHaving a way to reproduce your issue will help people confirm, investigate, and ultimately fix your issue. You can do this by providing an executable test case. To make this process easier, we have prepared an [executable bug report Rails application](./bug_report_template.rb) for you to use as a starting point.\n\nThis template includes the boilerplate code to set up a System Test case. Copy the content of the template into a `.rb` file and make the necessary changes to demonstrate the issue. You can execute it by running `ruby the_file.rb` in your terminal. If all goes well, you should see your test case failing.\n\nYou can then share your executable test case as a gist or paste the content into the issue description.\n\n## License\n\nTurbo is released under the [MIT License](https://opensource.org/licenses/MIT).\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/@hotwired/turbo-rails/-/turbo-rails-8.0.13.tgz#7016651f7144053992ce5096bb95495f8faa5854",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/@hotwired/turbo-rails/-/turbo-rails-8.0.13.tgz",
    "hash": "7016651f7144053992ce5096bb95495f8faa5854",
    "integrity": "sha512-6SCnnOSzhtaJ0pNkAjncZxjtKsK3sP/vPEkCnTXBXSHkr+vF7DTZkOlwjhms1DbbQNTsjCsBoKvzSMbh/omSCQ==",
    "registry": "npm",
    "packageName": "@hotwired/turbo-rails",
    "cacheIntegrity": "sha512-6SCnnOSzhtaJ0pNkAjncZxjtKsK3sP/vPEkCnTXBXSHkr+vF7DTZkOlwjhms1DbbQNTsjCsBoKvzSMbh/omSCQ== sha1-cBZlH3FEBTmSzlCWu5VJX4+qWFQ="
  },
  "registry": "npm",
  "hash": "7016651f7144053992ce5096bb95495f8faa5854"
}